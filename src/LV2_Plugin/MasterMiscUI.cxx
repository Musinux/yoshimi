// generated by Fast Light User Interface Designer (fluid) version 1.0302

#include "/home/louis/Documents/prog/Yoshimi/github/yoshimi/src/LV2_Plugin/MasterMiscUI.h"
// MasterUI.cc
// Original ZynAddSubFX author Nasca Octavian Paul
// Copyright (C) 2002-2005 Nasca Octavian Paul
// Copyright 2009-2011, Alan Calvert
// Copyright 2014, Will Godfrey    

// This file is part of yoshimi, which is free software: you can redistribute
// it and/or modify it under the terms of the GNU Library General Public
// License as published by the Free Software Foundation; either version 2 of
// the License, or (at your option) any later version.

// yoshimi is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.   See the GNU General Public License (version 2 or
// later) for more details.

// You should have received a copy of the GNU General Public License along with
// yoshimi; if not, write to the Free Software Foundation, Inc., 51 Franklin
// Street, Fifth Floor, Boston, MA  02110-1301, USA.

// This file is a derivative of the ZynAddSubFX original, modified October 2014

#include "MasterUI.h"

VUMeter::VUMeter(int x,int y, int w, int h, const char *label):Fl_Box(x,y,w,h,label) {
  npart=-1;
}

void VUMeter::init(int part_, SynthEngine *_synth) {
  // the "part_" parameters sets the part (if it is >=0), else it sets the master
  synth = _synth;
      label(NULL);
      npart = part_;
      oldpeakl = 0;
      oldpeakr = 0;
      oldrmsdbl = 0.0;
      oldrmsdbr = 0.0;
      maxdbl = NO_DB;
      maxdbr = NO_DB;
      clipped = 0;
      plgroup = &synth->getGuiMaster()->panelgroup;
      synth->VUdata.values.vuOutPeakL = 0.0;
      synth->VUdata.values.vuOutPeakR = 0.0;
      synth->VUdata.values.vuRmsPeakL = 0.0;
      synth->VUdata.values.vuRmsPeakR = 0.0;
      for (int i = 0; i < NUM_MIDI_PARTS; i++)
      {
          panelpart.oldpeak[i] = 0;
          panelpart.clip[i] = false;
          synth->VUdata.values.parts[i] = 0.0;
      }
}

void VUMeter::draw_master() {
  //
      int ox = x();
      int oy = y();
      int lx = w();
      int ly = h();
      float dbl = rap2dB(synth->VUdata.values.vuOutPeakL);
      float dbr = rap2dB(synth->VUdata.values.vuOutPeakR);
      float rmsdbl = rap2dB(synth->VUdata.values.vuRmsPeakL);
      float rmsdbr = rap2dB( synth->VUdata.values.vuRmsPeakR);
      
      clipped = clipped | (dbl > 0) | ((dbr > 0) << 1);
  
      if (dbl > maxdbl)
          maxdbl = dbl;
          if (dbr > maxdbr)
            maxdbr = dbr;
         
          dbl = (MIN_DB - dbl) / MIN_DB;
          if (dbl < 0.0)
              dbl = 0.0;
          else if (dbl > 1.0)
              dbl = 1.0;
          dbr = (MIN_DB - dbr) / MIN_DB;
          if (dbr < 0.0)
              dbr = 0.0;
          else if (dbr > 1.0)
              dbr = 1.0;
  #      define VULENX (lx-35)
  #      define VULENY (ly/2-3)
          dbl *= VULENX;
          dbr *= VULENX;
  
          if (dbl >= oldpeakl)
              oldpeakl = (int)dbl;
          else if (oldpeakl >= 8)
              oldpeakl -= 8;
          else if (oldpeakl)
              oldpeakl -= 1;
          if (dbr >= oldpeakr)
              oldpeakr = (int)dbr;
          else if (oldpeakr >= 8)
              oldpeakr -= 8;
          else if (oldpeakr)
              oldpeakr -= 1;
  
          // compute RMS - start
          rmsdbl = ((MIN_DB - rmsdbl) / MIN_DB);
          if (rmsdbl < 0.0)
              rmsdbl = 0.0;
          else if (rmsdbl >  1.0)
              rmsdbl =  1.0;
          rmsdbr = ((MIN_DB - rmsdbr) / MIN_DB);
          if (rmsdbr < 0.0)
              rmsdbr = 0.0;
          else if (rmsdbr >1.0)
              rmsdbr = 1.0;
          rmsdbl = (rmsdbl + oldrmsdbl * 7) / 8;
          rmsdbr = (rmsdbr + oldrmsdbr * 7) / 8;
          oldrmsdbl = rmsdbl;
          oldrmsdbr = rmsdbr;
          int irmsdbl = rmsdbl * VULENX;
          int irmsdbr = rmsdbr * VULENX;
          // compute RMS - end
  
          // draw db level
          fl_rectf(ox, oy, oldpeakl, VULENY, 0, 200, 255);
          fl_rectf(ox, oy + ly / 2, oldpeakr, VULENY, 0, 200, 255);
  
          // fill with black
          fl_rectf(ox + oldpeakl, oy, VULENX - oldpeakl, VULENY, 0, 0, 0);
          fl_rectf(ox + oldpeakr, oy + ly / 2, VULENX - oldpeakr, VULENY, 0, 0, 0);
  
          // draw scale
          float tmp = VULENX * 1.0 / MIN_DB;
          for (int i = 1; i < 1 - MIN_DB; ++i)
          {
             int tx = VULENX + (int)(tmp * i);
             fl_rectf(ox + tx, oy, 1, VULENY + ly / 2, 0, 160, 200);
             if (i % 5 == 0)
                 fl_rectf(ox + tx, oy, 1, VULENY + ly / 2, 0, 230, 240);
             if (i % 10 == 0)
                 fl_rectf(ox + tx - 1, oy, 2, VULENY + ly / 2, 0, 225, 255);
          }
  
          // mellow yellow rms indicator
          if (irmsdbl)
              fl_rectf(ox + irmsdbl - 1, oy, 3, VULENY, 255, 255, 0);
          if (irmsdbr)
              fl_rectf(ox + irmsdbr - 1, oy + ly / 2, 3, VULENY, 255, 255, 0);
  
          // see red if clipped
          if (clipped & 1)
              fl_rectf(ox + VULENX + 2, oy, lx - VULENX - 3, ly / 2 - 3, 250, 10, 10);
          else
              fl_rectf(ox + VULENX + 2, oy, lx - VULENX - 3, ly / 2 - 3, 0, 0, 10);
  
          if (clipped & 2)
              fl_rectf(ox + VULENX + 2, oy + ly / 2, lx - VULENX - 3, (ly - 2) / 2 - 2, 250, 10, 10);
          else
              fl_rectf(ox + VULENX + 2, oy + ly / 2, lx - VULENX - 3, (ly - 2) / 2 - 2, 0, 0, 10);
  
          // show maxdB
          static char tmpstr[8];
          const char *dbtag = "dB";
          if ((maxdbl > NO_DB))
          {
              fl_font(FL_HELVETICA | FL_BOLD, 9);
              fl_color(255, 255, 255);
              snprintf(tmpstr, 7, "%+3.f%s", maxdbl + 0.5f, dbtag);
              fl_draw(tmpstr, ox + VULENX + 1, oy + 1,
                      lx - VULENX - 4, VULENY - 2, FL_ALIGN_RIGHT, NULL, 0);
          }
          if ((maxdbr > NO_DB))
          {
              fl_font(FL_HELVETICA | FL_BOLD, 9);
              fl_color(255, 255, 255);
              snprintf(tmpstr, 7, "%+3.f%s", maxdbr + 0.5f, dbtag);
              fl_draw(tmpstr, ox + VULENX + 1, oy + ly / 2 + 1,
                      lx - VULENX - 4, VULENY, FL_ALIGN_RIGHT, NULL, 0);
          }
}

void VUMeter::draw_part() {
  int ox = x()+2;
      int oy = y()+2;
      int lx = w()-4;
      int ly = h()-4;
      float Vpeak = synth->VUdata.values.parts[npart + *plgroup];
      if (Vpeak < 0) // its a fake one
      {
          fl_rectf(ox, oy, lx, ly, 140, 140, 140);
          int fakedb = Vpeak / 127.0 * (ly - 16); // fiddle to make it the same height as normal
          fl_rectf(ox + 2, oy + ly + fakedb, lx - 4, -fakedb, 0, 0, 0);
          return;
      }
          
      if (Vpeak > 1.0)
          panelpart.clip[npart + *plgroup] = true;
   
      // draw the vu lines
      float db = rap2dB(Vpeak);
      db = (MIN_DB - db) / MIN_DB;
      db = (db > 1.0) ? 1.0 : db;
      db = db * ly - 2;
      if (db >= panelpart.oldpeak[npart + *plgroup])
          panelpart.oldpeak[npart + *plgroup] = (int) db;
      else if (panelpart.oldpeak[npart + *plgroup] >= 4)
          panelpart.oldpeak[npart + *plgroup] -= 4;
      else
          panelpart.oldpeak[npart + *plgroup] = 0;
          
      fl_rectf(ox, oy, lx, ly, 0, 0, 0);
      fl_rectf(ox, oy + ly - panelpart.oldpeak[npart + *plgroup], lx, panelpart.oldpeak[npart + *plgroup], 0, 200, 255);
  
      // draw the scales
      float tmp = ly * 1.0 / MIN_DB;
      for (int i = 1; i < 1 - MIN_DB; ++i)
      {
          int ty = ly + (int)(tmp * i);
          if ( i % 5 == 0)
              fl_rectf(ox, oy + ly - ty, lx, 1, 0, 160, 200);
          if (i % 10 == 0)
              fl_rectf(ox, oy + ly - ty, lx, 1, 0, 230, 240);
      }
      if (panelpart.clip[npart + *plgroup])
          fl_rectf(ox, oy, lx, 4, 255, 0, 0);
}

void VUMeter::draw() {
  if (npart>=0) draw_part();
      else draw_master();
}

void VUMeter::tickdraw(VUMeter *o) {
  o->redraw();
}

void VUMeter::tick(void *v) {
  tickdraw((VUMeter *) v);
      ((VUMeter *)v)->synth->fetchMeterData(&((VUMeter *) v)->synth->VUdata);
      Fl::add_timeout(0.05, tick, v); // 1.0 / 30.0 => 30 fps
}

int VUMeter::handle(int event) {
  switch(event){
          case FL_SHOW:
              tick(this);
              break;
          case FL_HIDE:
              Fl::remove_timeout(tick, this);
              break;
          case FL_PUSH:
              if (npart < 0)
              {
                  maxdbl = NO_DB;
                  maxdbr = NO_DB;
                  clipped = 0;
                 	MasterUI *masterUI = synth->getGuiMaster(false);
                 	if(masterUI)               
                 	{
                 		masterUI->resetPartsClip();
                 	}
              }
              break;
          }
          return 1;
}

void VUMeter::resetPart(bool clipOnly ) {
  for (int i = 0; i < NUM_MIDI_PARTS; i++)
        {
            panelpart.clip[i] = false;
        	  if(!clipOnly)
        	  {
  	          panelpart.oldpeak[i] = 0;
  	          synth->VUdata.values.parts[i] = 0.0;
  	  }
        }
}

SysEffSend::SysEffSend(int x,int y, int w, int h, const char *label):WidgetPDial(x,y,w,h,label) {
  neff1=0; neff2=0;
}

void SysEffSend::init(int neff1_, int neff2_, SynthEngine *_synth) {
  //
          synth = _synth;
          neff1 = neff1_;
          neff2 = neff2_;
          minimum(0);
          maximum(127);
          step(1);
          labelfont(0);
          labelsize(11);
          align(FL_ALIGN_TOP);
          value(synth->Psysefxsend[neff1][neff2]);
          copy_label((asString(neff1 + 1) + "->" + asString(neff2 + 1)).c_str());
}

SysEffSend::~SysEffSend() {
  hide();
}

int SysEffSend::handle(int event) {
  if (event == FL_PUSH || event == FL_DRAG)
          {
              synth->setPsysefxsend(neff1,neff2,value());
          }
          return WidgetPDial::handle(event);
}

void Panellistitem::cb_partname_i(Fl_Button*, void*) {
  //
    if ((int)bankui->cbwig->value() != (npart + 1 + *plgroup))
    {
        bankui->cbwig->value(npart + 1 + *plgroup);
        bankui->cbwig->do_callback();
    }
    bankui->Show();
    setPartLabel(findengines(npart | *plgroup));
}
void Panellistitem::cb_partname(Fl_Button* o, void* v) {
  ((Panellistitem*)(o->parent()->parent()->user_data()))->cb_partname_i(o,v);
}

void Panellistitem::cb_partvolume_i(Fl_Slider* o, void*) {
  //
              synth->part[npart + *plgroup]->setVolume(o->value());
              synth->getGuiMaster()->setPartVolWidget(npart + *plgroup, o->value());
}
void Panellistitem::cb_partvolume(Fl_Slider* o, void* v) {
  ((Panellistitem*)(o->parent()->parent()->user_data()))->cb_partvolume_i(o,v);
}

void Panellistitem::cb_partpanning_i(WidgetPDial* o, void*) {
  //
              synth->part[npart + *plgroup]->SetController(C_panning, o->value());
              synth->getGuiMaster()->setPartPanWidget(npart + *plgroup, o->value());
}
void Panellistitem::cb_partpanning(WidgetPDial* o, void* v) {
  ((Panellistitem*)(o->parent()->parent()->user_data()))->cb_partpanning_i(o,v);
}

void Panellistitem::cb_Edit_i(Fl_Button*, void*) {
  //
              if ((int)bankui->cbwig->value() != (npart + 1 + *plgroup))
              {
                  bankui->cbwig->value(npart + 1 + *plgroup);
                  bankui->cbwig->do_callback();
              }
              if (Fl::event() == FL_RELEASE and Fl::event_button() == FL_RIGHT_MOUSE)
                  synth->getGuiMaster()->showInstrumentEditWindow(npart + *plgroup);
}
void Panellistitem::cb_Edit(Fl_Button* o, void* v) {
  ((Panellistitem*)(o->parent()->parent()->user_data()))->cb_Edit_i(o,v);
}

void Panellistitem::cb_partrcv_i(Fl_Choice* o, void*) {
  //
              synth->part[npart + *plgroup]->Prcvchn=o->value();
              synth->getGuiMaster()->setPartMidiWidget(npart + *plgroup, o->value() + 1);
              o->textcolor(FL_BLACK);
}
void Panellistitem::cb_partrcv(Fl_Choice* o, void* v) {
  ((Panellistitem*)(o->parent()->parent()->user_data()))->cb_partrcv_i(o,v);
}

void Panellistitem::cb_audiosend_i(Fl_Choice* o, void*) {
  synth->SetPartDestination(npart + *plgroup, o->value() + 1);
}
void Panellistitem::cb_audiosend(Fl_Choice* o, void* v) {
  ((Panellistitem*)(o->parent()->parent()->user_data()))->cb_audiosend_i(o,v);
}

Fl_Menu_Item Panellistitem::menu_audiosend[] = {
 {"Main", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 10, 0},
 {"Part", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 10, 0},
 {"Both", 0,  0, 0, 0, FL_NORMAL_LABEL, 0, 10, 0},
 {0,0,0,0,0,0,0,0,0}
};
Fl_Menu_Item* Panellistitem::main = Panellistitem::menu_audiosend + 0;
Fl_Menu_Item* Panellistitem::part = Panellistitem::menu_audiosend + 1;
Fl_Menu_Item* Panellistitem::both = Panellistitem::menu_audiosend + 2;

void Panellistitem::cb_partenabled_i(Fl_Check_Button* o, void*) {
  synth->actionLock(lockmute);
            synth->partonoff(npart + *plgroup, o->value());
            synth->actionLock(unlock);
            if (o->value() == 0)
                panellistitemgroup->deactivate();
            else
            {
                panellistitemgroup->activate();
                if ((int)bankui->cbwig->value() != (npart + 1 + *plgroup))
                    bankui->cbwig->value(npart + 1 + *plgroup);
            }
            if ((int)bankui->cbwig->value() == (npart + 1 + *plgroup))
                bankui->cbwig->do_callback();
            o->redraw();
}
void Panellistitem::cb_partenabled(Fl_Check_Button* o, void* v) {
  ((Panellistitem*)(o->parent()->user_data()))->cb_partenabled_i(o,v);
}

Fl_Group* Panellistitem::make_window() {
  { panellistitem = new Fl_Group(0, 0, 60, 275);
    panellistitem->box(FL_FLAT_BOX);
    panellistitem->color(FL_BACKGROUND_COLOR);
    panellistitem->selection_color(FL_BACKGROUND_COLOR);
    panellistitem->labeltype(FL_NO_LABEL);
    panellistitem->labelfont(0);
    panellistitem->labelsize(14);
    panellistitem->labelcolor(FL_FOREGROUND_COLOR);
    panellistitem->user_data((void*)(this));
    panellistitem->align(Fl_Align(FL_ALIGN_TOP));
    panellistitem->when(FL_WHEN_RELEASE);
    { Fl_Group* o = panellistitemgroup = new Fl_Group(0, 20, 64, 252);
      panellistitemgroup->box(FL_PLASTIC_THIN_UP_BOX);
      { Fl_Group* o = new Fl_Group(42, 64, 16, 112);
        o->box(FL_ENGRAVED_FRAME);
        { partVUMeter = new VUMeter(43, 65, 14, 110, "V U");
          partVUMeter->box(FL_FLAT_BOX);
          partVUMeter->color(FL_FOREGROUND_COLOR);
          partVUMeter->selection_color((Fl_Color)75);
          partVUMeter->labeltype(FL_NORMAL_LABEL);
          partVUMeter->labelfont(0);
          partVUMeter->labelsize(14);
          partVUMeter->labelcolor((Fl_Color)55);
          partVUMeter->align(Fl_Align(FL_ALIGN_WRAP));
          partVUMeter->when(FL_WHEN_RELEASE);
          partVUMeter->init(npart, synth);
        } // VUMeter* partVUMeter
        o->end();
      } // Fl_Group* o
      { partadd = new Fl_Box(5, 28, 17, 27);
        partadd->box(FL_FLAT_BOX);
        partadd->deactivate();
      } // Fl_Box* partadd
      { partsub = new Fl_Box(23, 28, 17, 27);
        partsub->box(FL_FLAT_BOX);
        partsub->deactivate();
      } // Fl_Box* partsub
      { partpad = new Fl_Box(40, 28, 17, 27);
        partpad->box(FL_FLAT_BOX);
        partpad->deactivate();
      } // Fl_Box* partpad
      { partname = new Fl_Button(4, 27, 55, 30, "  ");
        partname->box(FL_THIN_DOWN_FRAME);
        partname->labelfont(1);
        partname->labelsize(10);
        partname->callback((Fl_Callback*)cb_partname);
        partname->align(Fl_Align(192|FL_ALIGN_INSIDE));
        setPartLabel(findengines(npart | *plgroup));
      } // Fl_Button* partname
      { Fl_Slider* o = partvolume = new Fl_Slider(8, 65, 30, 110);
        partvolume->type(4);
        partvolume->box(FL_THIN_DOWN_BOX);
        partvolume->minimum(127);
        partvolume->maximum(0);
        partvolume->step(1);
        partvolume->value(127);
        partvolume->callback((Fl_Callback*)cb_partvolume);
        o->value(synth->part[npart + *plgroup]->Pvolume);
      } // Fl_Slider* partvolume
      { WidgetPDial* o = partpanning = new WidgetPDial(17, 180, 30, 30);
        partpanning->box(FL_OVAL_BOX);
        partpanning->color(FL_BACKGROUND_COLOR);
        partpanning->selection_color(FL_INACTIVE_COLOR);
        partpanning->labeltype(FL_NORMAL_LABEL);
        partpanning->labelfont(0);
        partpanning->labelsize(14);
        partpanning->labelcolor(FL_FOREGROUND_COLOR);
        partpanning->maximum(127);
        partpanning->step(1);
        partpanning->callback((Fl_Callback*)cb_partpanning);
        partpanning->align(Fl_Align(FL_ALIGN_BOTTOM));
        partpanning->when(FL_WHEN_CHANGED);
        o->value(synth->part[npart + *plgroup]->Ppanning);
      } // WidgetPDial* partpanning
      { Fl_Button* o = new Fl_Button(12, 247, 40, 20, "Edit");
        o->tooltip("Left mouse button: Part select\nRight mouse button: Instrument edit");
        o->box(FL_PLASTIC_UP_BOX);
        o->labelsize(10);
        o->callback((Fl_Callback*)cb_Edit);
      } // Fl_Button* o
      { Fl_Choice* o = partrcv = new Fl_Choice(8, 210, 50, 15);
        partrcv->tooltip("receive from Midi channel");
        partrcv->down_box(FL_BORDER_BOX);
        partrcv->labelsize(10);
        partrcv->textfont(1);
        partrcv->textsize(10);
        partrcv->callback((Fl_Callback*)cb_partrcv);
        partrcv->align(Fl_Align(FL_ALIGN_TOP_LEFT));
        for(int i = 0; i < NUM_MIDI_CHANNELS; i++)
            {
                if (i == 9)
                    o->add("Dr10");
                else
                    o->add(string("Ch" + asString(i + 1)).c_str());
            }
        o->value(synth->part[npart + *plgroup]->Prcvchn);
      } // Fl_Choice* partrcv
      { Fl_Choice* o = audiosend = new Fl_Choice(8, 229, 50, 15);
        audiosend->tooltip("Set Audio Destination");
        audiosend->box(FL_BORDER_BOX);
        audiosend->down_box(FL_BORDER_BOX);
        audiosend->labelsize(9);
        audiosend->textsize(9);
        audiosend->callback((Fl_Callback*)cb_audiosend);
        audiosend->menu(menu_audiosend);
        if (synth->part[npart + *plgroup]->Paudiodest == 2) o->value(1); else if (synth->part[npart + *plgroup]->Paudiodest == 3) o->value(2); else o->value(0);
      } // Fl_Choice* audiosend
      if (synth->part[npart]->Penabled==0) o->deactivate();
      if (synth->getRuntime().audioEngine != jack_audio) audiosend->deactivate();
      panellistitemgroup->end();
    } // Fl_Group* panellistitemgroup
    { Fl_Check_Button* o = partenabled = new Fl_Check_Button(5, 0, 45, 20, "01");
      partenabled->down_box(FL_DOWN_BOX);
      partenabled->labeltype(FL_EMBOSSED_LABEL);
      partenabled->labelsize(15);
      partenabled->callback((Fl_Callback*)cb_partenabled);
      partenabled->align(Fl_Align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE));
      o->value(synth->part[npart + *plgroup]->Penabled);
    } // Fl_Check_Button* partenabled
    panellistitem->end();
  } // Fl_Group* panellistitem
  return panellistitem;
}

Panellistitem::Panellistitem(int x,int y, int w, int h, const char *label):Fl_Group(x,y,w,h,label) {
  npart = 0;
          bankui = NULL;
}

void Panellistitem::init(int npart_, BankUI *bankui_, SynthEngine *_synth) {
  //
      synth = _synth;
      npart=npart_;
      bankui = bankui_;
      plgroup = &synth->getGuiMaster()->panelgroup;
      make_window();
      panellistitem->show();
      end();
}

void Panellistitem::refresh() {
  //
  
      int setpart = npart | *plgroup; // assumes *plgroup always power of 2
  	
      partenabled->value(synth->part [setpart]->Penabled);
      if (synth->part[setpart]->Penabled != 0)
          panellistitemgroup->activate();
      else
          panellistitemgroup->deactivate();
      
      setPartLabel(findengines(setpart));        
      
      partvolume->value(synth->part[setpart]->Pvolume);
      partpanning->value(synth->part[setpart]->Ppanning);
      int tmpch = synth->part[setpart]->Prcvchn;
      if (tmpch < NUM_MIDI_CHANNELS)
      {
          partrcv->value(tmpch);
          partrcv->textcolor(FL_BLACK);
      }
      else
          partrcv->textcolor(FL_WHITE);
      partname->label(synth->part[setpart]->Pname.c_str());
      int tmp = synth->part[setpart]->Paudiodest - 1;
      if (tmp < 0 or tmp > 3)
          tmp = 0;
      audiosend->value(tmp);
      if ((int)bankui->cbwig->value() != (setpart + 1))
          panellistitemgroup->color(fl_rgb_color(160, 160, 160));
      else
          panellistitemgroup->color(fl_rgb_color(50,190,240));
      panellistitemgroup->redraw();
      string num = asString(setpart + 1);
      partenabled->copy_label(num.c_str());
}

void Panellistitem::setPartLabel(int engine) {
  //
      if (engine & 1)
          partadd->color(ADD_COLOUR);
      else
          partadd->color(BASE_COLOUR);
      partadd->redraw();
      if (engine & 2)
          partsub->color(SUB_COLOUR);
      else
          partsub->color(BASE_COLOUR);
      partsub->redraw();
      if (engine & 4)
          partpad->color(PAD_COLOUR);
      else
          partpad->color(BASE_COLOUR);
      partpad->redraw();
      partname->label(synth->part[npart | *plgroup]->Pname.c_str());
}

unsigned int Panellistitem::findengines(int npart) {
  //
      unsigned int engine = 0;
      if (synth->getRuntime().checksynthengines)
      {
          for(int i = 0; i < NUM_KIT_ITEMS; ++i)
          {
              if (synth->part[npart]->kit[i].Padenabled)
                  engine |= 1;
              if (synth->part[npart]->kit[i].Psubenabled)
                  engine |= 2;
              if (synth->part[npart]->kit[i].Ppadenabled)
                  engine |= 4;
          }
      }
      return engine;
}

Panellistitem::~Panellistitem() {
  panellistitem->hide();
}
