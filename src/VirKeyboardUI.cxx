// generated by Fast Light User Interface Designer (fluid) version 1.0302

#include "/home/louis/Documents/prog/Yoshimi/github/yoshimi/src/VirKeyboardUI.h"
// VirKeyboard.cc

// Original ZynAddSubFX author Nasca Octavian Paul
// Copyright (C) 2002-2005 Nasca Octavian Paul
// Copyright 2009-2010, Alan Calvert
// Copyright 2014, Will Godfrey    

// This file is part of yoshimi, which is free software: you can redistribute
// it and/or modify it under the terms of the GNU Library General Public
// License as published by the Free Software Foundation; either version 2 of
// the License, or (at your option) any later version.

// yoshimi is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.   See the GNU General Public License (version 2 or
// later) for more details.

// You should have received a copy of the GNU General Public License along with
// yoshimi; if not, write to the Free Software Foundation, Inc., 51 Franklin
// Street, Fifth Floor, Boston, MA  02110-1301, USA.

// This file is a derivative of origional ZynAddSubFX code, modified June 2014

static const int keyspos[12]={0,-1,1,-2,2,3,-4,4,-5,5,-6,6}; 
static const int keysoct1qwerty[]={'q','2','w','3','e','r','5','t','6','y','7','u','i','9','o','0','p','[','=',']','\\',FL_Enter,0}; 
static const int keysoct2qwerty[]={'z','s','x','d','c','v','g','b','h','n','j','m',',','l','.',';','/',0}; 
static const int keysoct1dw[]={'\'','2',',','3','.','p','5','y','6','f','7','g','c','9','r','0','l','/',']','=','\\',FL_Enter,0}; 
static const int keysoct2dw[]={';','o','q','e','j','k','i','x','d','b','h','m','w','n','v','s','z',0}; 
static const int keysoct1qwertz[]={'q','2','w','3','e','r','5','t','6','z','7','u','i','9','o','0','p',252,'\'','+','\\',FL_Enter,0}; 
static const int keysoct2qwertz[]={'y','s','x','d','c','v','g','b','h','n','j','m',',','l','.',246,'-',0}; 
static const int keysoct1azerty[]={'a',233,'z','\"','e','r','(','t','-','y',232,'u','i',231,'o',224,'p',65106,'=','$',0}; 
static const int keysoct2azerty[]={'w','s','x','d','c','v','g','b','h','n','j',',',';','l',':','m','!',0}; 

VirKeys::VirKeys(int x,int y, int w, int h, const char *label):Fl_Box(x,y,w,h,label) {
}

void VirKeys::init(SynthEngine *_synth) {
  synth = _synth;
  for (int i = 0; i < N_OCT * 12 + 1; ++i)
              pressed[i] = 0;
          midich = 0;
          midivel = 100;
          midioct = 2;
          keyoct1 = 3;
          keyoct2 = 2;
          rndvelocity = 0;
}

void VirKeys::draw() {
  int ox = x(), oy = y(), lx = w(), ly = h() - 1, i;
          if (damage() != 1)
          {
              fl_color(250, 240, 230);
              fl_rectf(ox, oy, lx, ly);
  
              fl_color(FL_BLACK);
              fl_line(ox, oy, ox + lx, oy);
              fl_line(ox, oy + ly, ox + lx, oy + ly);
              for (i = 0; i < N_OCT * 7 + 1; ++i)
              {
                  fl_line(ox + i * SIZE_WHITE, oy, ox + i * SIZE_WHITE, oy + ly);
                  int ik = i % 7;
                  if (ik == 1 || ik == 2 || ik == 4 || ik == 5 || ik == 6)
                      fl_rectf(ox + i * SIZE_WHITE - SIZE_BLACK / 2, oy,
                               SIZE_BLACK + 1, ly * 3 / 5);
              }
          }
  
          for (i = 0; i < N_OCT * 12; ++i)
          {
              // if (pressed[i]==0) continue;
  
              int noct = i / 12;
              int kv = keyspos[i % 12];
              if (kv >= 0)
              {   // white keys
                  if (pressed[i] == 0)
                      fl_color(250, 240, 230);
                  else
                      fl_color(FL_BLUE);
                  fl_rectf(ox + (kv + 7 * noct) * SIZE_WHITE + 3, oy + ly * 3 / 5 + 2,
                           SIZE_WHITE - 4, ly * 2 / 5 - 3);
              }
              else
              {   // black keys
                  kv = keyspos[(i + 1) % 12];
                  if (pressed[i] == 0)
                      fl_color(FL_BLACK);
                  else
                      fl_color(FL_BLUE);
                  fl_rectf(ox + (kv + 7 * noct) * SIZE_WHITE - SIZE_BLACK / 2 + 2, oy + 2,
                           SIZE_BLACK - 3, ly * 3 / 5 - 5);
              }
          }
}

int VirKeys::handle(int event) {
  int i;
          int ly = h();
          int x_ = Fl::event_x() - x();
          int y_ = Fl::event_y() - y();
          if (x_ < 0 && x_ > w() && y_ < 0 && y_>h())
              return 0;
          if (event == FL_PUSH || event == FL_DRAG || event == FL_RELEASE)
          {
              int kpos = -1;
    
              if (y_ > ly * 3 / 5)
              {   // white keys
                  int pos = x_ / SIZE_WHITE;
                  if (pos < 0)
                      return 1;
                  for (i = 0; i < 12; ++i)
                  {
                      if (pos % 7 == keyspos[i])
                      {
                          kpos = pos / 7 * 12 + i;
                          break;
                      }
                  }
              }
              else
              {   // black keys
                  int pos = (x_ + SIZE_WHITE / 2) / SIZE_WHITE;
                  if (pos < 0)
                      return 1;
                  for (i = 1; i < 12; ++i)
                  {
                      if (pos % 7 == -keyspos[i])
                      {
                          kpos = pos / 7 * 12 + i;
                          break;
                      }
                  }
              }
  
              if (Fl::event_shift() == 0 && (event == FL_PUSH || event==FL_DRAG))
                  presskey(kpos, 1, 1);
  
              if (event == FL_PUSH && Fl::event_shift() != 0)
              {
                  if (pressed[kpos] == 0)
                      presskey(kpos, 0, 1);
                  else
                      relasekey(kpos, 1);
              }
              if (event == FL_RELEASE && Fl::event_shift() == 0)
                  relaseallkeys(1);
              take_focus();
          }
  
          const int *keysoct1 = keysoct1qwerty;
          const int *keysoct2 = keysoct2qwerty;
  
          if (synth->getRuntime().VirKeybLayout == 2)
          {
              keysoct1 = keysoct1dw;
              keysoct2 = keysoct2dw;
          }
          else if (synth->getRuntime().VirKeybLayout == 3)
          {
              keysoct1 = keysoct1qwertz;
              keysoct2 = keysoct2qwertz;
          }
          else if (synth->getRuntime().VirKeybLayout == 4) 
          {
              keysoct1 = keysoct1azerty;
              keysoct2 = keysoct2azerty;
          }
  
          if (event == FL_KEYDOWN || event == FL_KEYUP)
          {
              int key = Fl::event_key();
              int kpos = -1;
              for (i = 0; keysoct1[i] != 0; ++i)
                  if (key == keysoct1[i])
                      kpos = i + 12 * keyoct1;
              for (i = 0; keysoct2[i] != 0; ++i)
                  if (key == keysoct2[i])
                      kpos = i + 12 * keyoct2;
  
              if (kpos == -1)
                  return 0;
              if (event == FL_KEYUP && Fl::event_key(key) == 0 && Fl::get_key(key) != 0)
                  return 0;
              if (event == FL_KEYDOWN)
                  presskey(kpos, 0, 2);
              else
                  relasekey(kpos, 2);
          }
          return 1;
}

void VirKeys::presskey(int nk,int exclusive,int type) {
  // Exclusive means that multiple keys can be pressed at once
          // when the user uses the shift key
          if (nk >= N_OCT * 12)
              return;
          if (nk < 0 && exclusive == 0)
          {
              relaseallkeys(type);
              return;
          }
          if (nk < 0)
              return;
          if (pressed[nk] != 0)
              return; // the key is already pressed
  
          if (exclusive != 0)
              relaseallkeys(type);
          pressed[nk] = type;
  
          damage(1);
          float vel = midivel;
          if (rndvelocity != 0)
          {
              vel = midivel * (127.0 - rndvelocity) / 127.0 + synth->numRandom() * rndvelocity;
          }
          synth->NoteOn(midich, nk + midioct * 12, vel);
}

void VirKeys::relasekey(int nk,int type) {
  //
          if (nk < 0 || nk >= N_OCT * 12)
              return;
          if (pressed[nk] == 0)
              return; // the key is not pressed
          if (type != 0 && pressed[nk] != type)
              return;
          pressed[nk] = 0;
          damage(1);
          synth->NoteOff(midich, nk + 12 * midioct);
}

void VirKeys::relaseallkeys(int type) {
  for (int i = 0; i < N_OCT * 12; ++i)
              relasekey(i, type);
}

void VirKeyboard::cb_virkeyboardwindow_i(Fl_Double_Window*, void*) {
  relaseallkeys();
virkeyboardwindow->hide();
}
void VirKeyboard::cb_virkeyboardwindow(Fl_Double_Window* o, void* v) {
  ((VirKeyboard*)(o->user_data()))->cb_virkeyboardwindow_i(o,v);
}

void VirKeyboard::cb_qwer_i(Fl_Counter* o, void*) {
  relaseallkeys();
            virkeys->keyoct1 = (int)o->value();
            virkeys->take_focus();
}
void VirKeyboard::cb_qwer(Fl_Counter* o, void* v) {
  ((VirKeyboard*)(o->parent()->user_data()))->cb_qwer_i(o,v);
}

void VirKeyboard::cb_zxcv_i(Fl_Counter* o, void*) {
  relaseallkeys();
virkeys->keyoct2=(int) o->value();
virkeys->take_focus();
}
void VirKeyboard::cb_zxcv(Fl_Counter* o, void* v) {
  ((VirKeyboard*)(o->parent()->user_data()))->cb_zxcv_i(o,v);
}

void VirKeyboard::cb_Velocity_i(Fl_Value_Slider* o, void*) {
  virkeys->midivel=(int) o->value();
virkeys->take_focus();
}
void VirKeyboard::cb_Velocity(Fl_Value_Slider* o, void* v) {
  ((VirKeyboard*)(o->parent()->user_data()))->cb_Velocity_i(o,v);
}

void VirKeyboard::cb_Octave_i(Fl_Counter* o, void*) {
  relaseallkeys();
virkeys->midioct=(int) o->value();
virkeys->take_focus();
}
void VirKeyboard::cb_Octave(Fl_Counter* o, void* v) {
  ((VirKeyboard*)(o->parent()->user_data()))->cb_Octave_i(o,v);
}

void VirKeyboard::cb_Close_i(Fl_Button*, void*) {
  relaseallkeys();
virkeyboardwindow->hide();
}
void VirKeyboard::cb_Close(Fl_Button* o, void* v) {
  ((VirKeyboard*)(o->parent()->user_data()))->cb_Close_i(o,v);
}

void VirKeyboard::cb_Cval_i(Fl_Value_Slider* o, void*) {
  int ctl = midictl;
            synth->SetController(virkeys->midich, ctl, (int) o->value());
            virkeys->take_focus();
}
void VirKeyboard::cb_Cval(Fl_Value_Slider* o, void* v) {
  ((VirKeyboard*)(o->parent()->user_data()))->cb_Cval_i(o,v);
}

void VirKeyboard::cb_Controller_i(Fl_Choice* o, void*) {
  switch((int) o->value() + 1)
            {
                case 1: midictl = C_modwheel; break;
                case 2: midictl = C_volume; break;
                case 3: midictl = C_panning; break;
                case 4: midictl = C_expression; break;
                case 5: midictl = C_sustain; break;
                case 6: midictl = C_portamento; break;
                case 7: midictl = C_filterq; break;
                case 8: midictl = C_filtercutoff; break;
                case 9: midictl = C_bandwidth; break;
                case 10: midictl = C_fmamp; break;
                case 11: midictl = C_resonance_center; break;
                case 12: midictl = C_resonance_bandwidth; break;
                default: midictl = C_NULL; break;
            }
            virkeys->take_focus();
}
void VirKeyboard::cb_Controller(Fl_Choice* o, void* v) {
  ((VirKeyboard*)(o->parent()->user_data()))->cb_Controller_i(o,v);
}

Fl_Menu_Item VirKeyboard::menu_Controller[] = {
 {"01: Mod.Wheel", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"07: Volume", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"10: Panning", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"11: Expression", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"64: Sustain", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"65: Portamento", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"71: Filter Q", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"74: Filter Freq.", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"75: Bandwidth", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"76: FM Gain", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"77: Res. c. freq", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {"78: Res. bw.", 0,  0, 0, 0, FL_NORMAL_LABEL, 1, 10, 0},
 {0,0,0,0,0,0,0,0,0}
};

void VirKeyboard::cb_pitchwheelroller_i(Fl_Roller* o, void*) {
  synth->SetController(virkeys->midich, C_pitchwheel, -(int) o->value());
            virkeys->take_focus();
}
void VirKeyboard::cb_pitchwheelroller(Fl_Roller* o, void* v) {
  ((VirKeyboard*)(o->parent()->user_data()))->cb_pitchwheelroller_i(o,v);
}

void VirKeyboard::cb_R_i(Fl_Button*, void*) {
  pitchwheelroller->value(0);
            pitchwheelroller->do_callback();
}
void VirKeyboard::cb_R(Fl_Button* o, void* v) {
  ((VirKeyboard*)(o->parent()->user_data()))->cb_R_i(o,v);
}

void VirKeyboard::cb_Vrnd_i(WidgetPDial* o, void*) {
  virkeys->rndvelocity=(int) o->value();
}
void VirKeyboard::cb_Vrnd(WidgetPDial* o, void* v) {
  ((VirKeyboard*)(o->parent()->user_data()))->cb_Vrnd_i(o,v);
}

void VirKeyboard::cb_midichannel_i(Fl_Spinner* o, void*) {
  //
            relaseallkeys();
            virkeys->midich = lrint(o->value()) - 1;
            virkeys->take_focus();
}
void VirKeyboard::cb_midichannel(Fl_Spinner* o, void* v) {
  ((VirKeyboard*)(o->parent()->user_data()))->cb_midichannel_i(o,v);
}

Fl_Double_Window* VirKeyboard::make_window() {
  { virkeyboardwindow = new Fl_Double_Window(650, 130, "Yoshimi Virtual Keyboard");
    virkeyboardwindow->callback((Fl_Callback*)cb_virkeyboardwindow, (void*)(this));
    { VirKeys* o = virkeys = new VirKeys(32, 10, 590, 80, "Keyboard");
      virkeys->box(FL_FLAT_BOX);
      virkeys->color((Fl_Color)17);
      virkeys->selection_color(FL_BACKGROUND_COLOR);
      virkeys->labeltype(FL_NORMAL_LABEL);
      virkeys->labelfont(0);
      virkeys->labelsize(14);
      virkeys->labelcolor(FL_FOREGROUND_COLOR);
      virkeys->align(Fl_Align(FL_ALIGN_CENTER));
      virkeys->when(FL_WHEN_RELEASE);
      o->init(synth);
    } // VirKeys* virkeys
    { Fl_Counter* o = new Fl_Counter(390, 95, 45, 15, "\"qwer..\" Oct");
      o->tooltip("keys \"q2w3er5t6y...\" octave");
      o->type(1);
      o->labelsize(10);
      o->minimum(0);
      o->maximum(5);
      o->step(1);
      o->textfont(1);
      o->textsize(10);
      o->callback((Fl_Callback*)cb_qwer);
      o->align(Fl_Align(FL_ALIGN_LEFT));
      o->when(FL_WHEN_RELEASE_ALWAYS);
      o->value(virkeys->keyoct1);
    } // Fl_Counter* o
    { Fl_Counter* o = new Fl_Counter(390, 110, 45, 15, "\"zxcv..\" Oct");
      o->tooltip("keys \"zsxdcvgbh...\" octave");
      o->type(1);
      o->labelsize(10);
      o->minimum(0);
      o->maximum(5);
      o->step(1);
      o->textfont(1);
      o->textsize(10);
      o->callback((Fl_Callback*)cb_zxcv);
      o->align(Fl_Align(FL_ALIGN_LEFT));
      o->when(FL_WHEN_RELEASE_ALWAYS);
      o->value(virkeys->keyoct2);
    } // Fl_Counter* o
    { Fl_Value_Slider* o = new Fl_Value_Slider(96, 106, 110, 16, "Velocity");
      o->tooltip("Velocity");
      o->type(5);
      o->box(FL_FLAT_BOX);
      o->labelsize(10);
      o->minimum(1);
      o->maximum(127);
      o->step(1);
      o->callback((Fl_Callback*)cb_Velocity);
      o->align(Fl_Align(FL_ALIGN_TOP));
      o->value(virkeys->midivel);
    } // Fl_Value_Slider* o
    { Fl_Counter* o = new Fl_Counter(257, 106, 56, 18, "Octave");
      o->tooltip("Midi Octave");
      o->type(1);
      o->labelsize(10);
      o->minimum(0);
      o->maximum(5);
      o->step(1);
      o->textfont(1);
      o->textsize(10);
      o->callback((Fl_Callback*)cb_Octave);
      o->align(Fl_Align(FL_ALIGN_TOP));
      o->when(FL_WHEN_RELEASE_ALWAYS);
      o->value(virkeys->midioct);
    } // Fl_Counter* o
    { Fl_Button* o = new Fl_Button(452, 101, 55, 20, "Close");
      o->box(FL_THIN_UP_BOX);
      o->labelsize(12);
      o->callback((Fl_Callback*)cb_Close);
    } // Fl_Button* o
    { Fl_Value_Slider* o = new Fl_Value_Slider(630, 10, 15, 115, "Cval");
      o->tooltip("Controller value");
      o->type(2);
      o->box(FL_ENGRAVED_BOX);
      o->selection_color((Fl_Color)229);
      o->labelsize(8);
      o->minimum(127);
      o->maximum(0);
      o->step(1);
      o->value(64);
      o->textsize(7);
      o->callback((Fl_Callback*)cb_Cval);
      o->align(Fl_Align(FL_ALIGN_TOP_LEFT));
    } // Fl_Value_Slider* o
    { Fl_Choice* o = new Fl_Choice(524, 105, 100, 15, "Controller");
      o->down_box(FL_BORDER_BOX);
      o->labelsize(10);
      o->textfont(1);
      o->textsize(10);
      o->callback((Fl_Callback*)cb_Controller);
      o->align(Fl_Align(FL_ALIGN_TOP));
      o->when(FL_WHEN_RELEASE_ALWAYS);
      o->menu(menu_Controller);
      midictl=C_filtercutoff;o->value(7);
    } // Fl_Choice* o
    { pitchwheelroller = new Fl_Roller(5, 10, 20, 95, "Pwh");
      pitchwheelroller->tooltip("Pitch Wheel");
      pitchwheelroller->box(FL_PLASTIC_UP_BOX);
      pitchwheelroller->labelsize(8);
      pitchwheelroller->minimum(-8192);
      pitchwheelroller->maximum(8192);
      pitchwheelroller->step(64);
      pitchwheelroller->callback((Fl_Callback*)cb_pitchwheelroller);
      pitchwheelroller->align(Fl_Align(FL_ALIGN_TOP));
      pitchwheelroller->when(3);
    } // Fl_Roller* pitchwheelroller
    { Fl_Button* o = new Fl_Button(5, 110, 20, 15, "R");
      o->tooltip("Reset Pitch Bend");
      o->box(FL_THIN_UP_BOX);
      o->labelfont(1);
      o->callback((Fl_Callback*)cb_R);
    } // Fl_Button* o
    { WidgetPDial* o = new WidgetPDial(221, 106, 20, 21, "Vrnd");
      o->tooltip("Velocity Randomness");
      o->box(FL_ROUND_UP_BOX);
      o->color(FL_BACKGROUND_COLOR);
      o->selection_color(FL_INACTIVE_COLOR);
      o->labeltype(FL_NORMAL_LABEL);
      o->labelfont(0);
      o->labelsize(10);
      o->labelcolor(FL_FOREGROUND_COLOR);
      o->maximum(127);
      o->step(1);
      o->callback((Fl_Callback*)cb_Vrnd);
      o->align(Fl_Align(129));
      o->when(FL_WHEN_CHANGED);
      o->value(virkeys->rndvelocity);
    } // WidgetPDial* o
    { Fl_Spinner* o = midichannel = new Fl_Spinner(45, 106, 36, 17, "Midi Channel");
      midichannel->labelsize(9);
      midichannel->maximum(16);
      midichannel->textsize(10);
      midichannel->callback((Fl_Callback*)cb_midichannel);
      midichannel->align(Fl_Align(FL_ALIGN_TOP));
      o->value(virkeys->midich + 1);
    } // Fl_Spinner* midichannel
    virkeyboardwindow->end();
  } // Fl_Double_Window* virkeyboardwindow
  return virkeyboardwindow;
}

VirKeyboard::VirKeyboard(SynthEngine *_synth) {
  synth = _synth;
  midictl = 75;
          make_window();
          keyboardlabel = synth->makeUniqueName("Yoshimi Virtual Keyboard");
          virkeyboardwindow->label(keyboardlabel.c_str());
}

VirKeyboard::~VirKeyboard() {
  delete virkeyboardwindow;
}

void VirKeyboard::Show() {
  virkeyboardwindow->show();
}

void VirKeyboard::Hide() {
  virkeyboardwindow->hide();
}

void VirKeyboard::relaseallkeys() {
  virkeys->relaseallkeys(0);
}
